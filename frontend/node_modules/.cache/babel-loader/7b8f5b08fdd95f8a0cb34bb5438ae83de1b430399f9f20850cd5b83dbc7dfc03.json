{"ast":null,"code":"var _jsxFileName = \"/Applications/MAMP/htdocs/IS213-TicketMaster/frontend/ticketmaster/src/components/ui/SimpleSparkles.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SimpleSparkles = ({\n  className,\n  particleColor = '#57A5FF',\n  particleCount = 120,\n  // Reduced count for better performance\n  minSize = 4,\n  // Slightly smaller for better performance\n  maxSize = 8,\n  // Slightly smaller for better performance\n  speed = 1.0,\n  // Reduced speed for smoother motion\n  connectDistance = 180\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d', {\n      alpha: true,\n      willReadFrequently: false\n    });\n    let particles = [];\n    let animationSpeed = 1;\n    let animationFrameId = null;\n    let hasRenderedFirstFrame = false;\n\n    // Preprocessing color values to avoid string parsing in animation loop\n    const baseColor = particleColor;\n    const baseR = parseInt(baseColor.slice(1, 3), 16);\n    const baseG = parseInt(baseColor.slice(3, 5), 16);\n    const baseB = parseInt(baseColor.slice(5, 7), 16);\n\n    // Brightened values (precomputed)\n    const brightR = Math.min(255, baseR + 80);\n    const brightG = Math.min(255, baseG + 80);\n    const brightB = Math.min(255, baseB + 80);\n\n    // More smooth resize handling with debouncing\n    let resizeTimeout;\n    const handleResize = () => {\n      clearTimeout(resizeTimeout);\n      resizeTimeout = setTimeout(() => {\n        setupCanvas();\n      }, 100);\n    };\n\n    // Setup canvas with proper scaling\n    const setupCanvas = () => {\n      const devicePixelRatio = window.devicePixelRatio || 1;\n      const pixelRatio = Math.min(devicePixelRatio, 1.5); // Cap at 1.5x for performance\n\n      // Get display size\n      const displayWidth = canvas.clientWidth;\n      const displayHeight = canvas.clientHeight;\n\n      // Set canvas size for HiDPI display\n      canvas.width = Math.floor(displayWidth * pixelRatio);\n      canvas.height = Math.floor(displayHeight * pixelRatio);\n\n      // Reset transform before scaling\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.scale(pixelRatio, pixelRatio);\n\n      // Avoid blurry lines\n      ctx.translate(0.5, 0.5);\n\n      // Enable antialiasing for gradients\n      ctx.imageSmoothingEnabled = true;\n      ctx.imageSmoothingQuality = 'high';\n      createParticles();\n    };\n\n    // Create particles\n    const createParticles = () => {\n      particles = []; // Clear existing particles\n\n      // Adjust particle count based on canvas size for performance\n      const area = canvas.clientWidth * canvas.clientHeight / 250000;\n      const adjustedCount = Math.min(particleCount, Math.max(40, Math.floor(particleCount * Math.min(1, area))));\n      for (let i = 0; i < adjustedCount; i++) {\n        const angle = Math.random() * Math.PI * 2;\n        const speedFactor = (Math.random() * 0.5 + 0.5) * speed;\n        particles.push({\n          x: Math.random() * canvas.clientWidth,\n          y: Math.random() * canvas.clientHeight,\n          size: Math.random() * (maxSize - minSize) + minSize,\n          speedX: Math.cos(angle) * speedFactor,\n          speedY: Math.sin(angle) * speedFactor,\n          opacity: Math.random() * 0.3 + 0.7,\n          targetOpacity: Math.random() * 0.3 + 0.7,\n          // Target for smooth transitions\n          // Store precomputed color values\n          r: brightR,\n          g: brightG,\n          b: brightB,\n          acceleration: Math.random() * 0.008 + 0.002,\n          // Reduced for smoother movement\n          maxSpeed: speedFactor * 1.2,\n          // Slightly reduced max speed\n          // Add properties for optimization\n          connectionCheckFrame: i % 3 // Distribute connection checks across frames\n        });\n      }\n    };\n\n    // Smooth opacity transitions to prevent flickering\n    const updateParticleOpacity = (particle, delta) => {\n      // Update target opacity occasionally\n      if (Math.random() < 0.03) {\n        particle.targetOpacity = Math.random() * 0.3 + 0.7;\n      }\n\n      // Smoothly transition current opacity to target\n      const diff = particle.targetOpacity - particle.opacity;\n      particle.opacity += diff * 0.03 * (delta / 16);\n    };\n\n    // Animation loop with consistent timing\n    let lastTime = 0;\n    let frameCount = 0;\n    const animate = timestamp => {\n      if (!hasRenderedFirstFrame) {\n        hasRenderedFirstFrame = true;\n      }\n\n      // Calculate delta time (with safety caps)\n      const deltaTime = lastTime ? Math.min(timestamp - lastTime, 33) : 16; // Cap at ~30fps equivalent\n      lastTime = timestamp;\n      const delta = deltaTime * animationSpeed;\n      frameCount++;\n\n      // Clear with alpha for smoother transitions\n      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);\n\n      // Connection map for optimization\n      const connectionsToRender = [];\n\n      // Update particle positions first\n      for (let i = 0; i < particles.length; i++) {\n        const p = particles[i];\n\n        // Smooth opacity updates\n        updateParticleOpacity(p, delta);\n\n        // Smoother acceleration adjustments\n        if (frameCount % 3 === 0) {\n          // Reduced frequency for smoother movement\n          const acceleration = p.acceleration * delta;\n          p.speedX += (Math.random() - 0.5) * acceleration;\n          p.speedY += (Math.random() - 0.5) * acceleration;\n\n          // Cap the speed\n          const currentSpeed = Math.sqrt(p.speedX * p.speedX + p.speedY * p.speedY);\n          if (currentSpeed > p.maxSpeed) {\n            const ratio = p.maxSpeed / currentSpeed;\n            p.speedX *= ratio;\n            p.speedY *= ratio;\n          }\n        }\n\n        // Update position with delta time scaling\n        p.x += p.speedX * (delta / 16);\n        p.y += p.speedY * (delta / 16);\n\n        // Bounce off edges with smoother transitions\n        if (p.x < 0 || p.x > canvas.clientWidth) {\n          p.speedX = -p.speedX;\n          p.x = p.x < 0 ? 0 : canvas.clientWidth;\n        }\n        if (p.y < 0 || p.y > canvas.clientHeight) {\n          p.speedY = -p.speedY;\n          p.y = p.y < 0 ? 0 : canvas.clientHeight;\n        }\n\n        // Distribute connection checks across frames\n        if (p.connectionCheckFrame === frameCount % 3) {\n          const checkLimit = Math.min(particles.length, i + 20); // Check fewer particles\n\n          for (let j = i + 1; j < checkLimit; j++) {\n            const p2 = particles[j];\n\n            // Quick distance check first (square distance is faster than sqrt)\n            const dx = p.x - p2.x;\n            const dy = p.y - p2.y;\n            const squareDistance = dx * dx + dy * dy;\n            if (squareDistance < connectDistance * connectDistance) {\n              const distance = Math.sqrt(squareDistance);\n              if (distance < connectDistance) {\n                connectionsToRender.push({\n                  x1: p.x,\n                  y1: p.y,\n                  x2: p2.x,\n                  y2: p2.y,\n                  distance: distance,\n                  opacity1: p.opacity,\n                  opacity2: p2.opacity,\n                  r: p.r,\n                  g: p.g,\n                  b: p.b\n                });\n              }\n            }\n          }\n        }\n      }\n\n      // Now render particles (separate from position updates)\n      // First render connections (behind particles)\n      ctx.globalCompositeOperation = 'source-over';\n\n      // Batch render connections\n      for (let i = 0; i < connectionsToRender.length; i++) {\n        const conn = connectionsToRender[i];\n        ctx.beginPath();\n\n        // Higher base opacity for connections\n        const connectionOpacity = (1 - conn.distance / connectDistance) * 0.7;\n\n        // Use gradient\n        const gradient = ctx.createLinearGradient(conn.x1, conn.y1, conn.x2, conn.y2);\n        gradient.addColorStop(0, `rgba(${conn.r}, ${conn.g}, ${conn.b}, ${connectionOpacity * conn.opacity1})`);\n        gradient.addColorStop(0.5, `rgba(255, 255, 255, ${connectionOpacity * 0.6})`);\n        gradient.addColorStop(1, `rgba(${conn.r}, ${conn.g}, ${conn.b}, ${connectionOpacity * conn.opacity2})`);\n        ctx.strokeStyle = gradient;\n        ctx.lineWidth = 1.0; // Slightly thinner for performance\n        ctx.moveTo(conn.x1, conn.y1);\n        ctx.lineTo(conn.x2, conn.y2);\n        ctx.stroke();\n      }\n\n      // Then render particles (on top of connections)\n      for (let i = 0; i < particles.length; i++) {\n        const p = particles[i];\n\n        // Define colors outside the loop for reuse\n        const particleFillColor = `rgba(${p.r}, ${p.g}, ${p.b}, ${p.opacity})`;\n        const particleWhiteColor = `rgba(255, 255, 255, ${p.opacity})`;\n\n        // Use shadow only for larger particles to reduce flicker\n        if (i % 10 === 0 && p.size > minSize + 1) {\n          ctx.shadowBlur = 10;\n          ctx.shadowColor = particleFillColor;\n        } else {\n          ctx.shadowBlur = 0;\n        }\n\n        // Draw particle\n        ctx.beginPath();\n\n        // Create radial gradient\n        const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);\n        gradient.addColorStop(0, particleWhiteColor);\n        gradient.addColorStop(0.4, particleFillColor);\n        gradient.addColorStop(1, `rgba(${p.r}, ${p.g}, ${p.b}, 0)`);\n        ctx.arc(p.x, p.y, p.size * 1.2, 0, Math.PI * 2);\n        ctx.fillStyle = gradient;\n        ctx.fill();\n      }\n      ctx.shadowBlur = 0; // Reset shadow\n\n      animationFrameId = requestAnimationFrame(animate);\n    };\n\n    // Initialize\n    setupCanvas();\n    window.addEventListener('resize', handleResize);\n\n    // Start animation\n    animationFrameId = requestAnimationFrame(animate);\n\n    // Cleanup\n    return () => {\n      clearTimeout(resizeTimeout);\n      window.removeEventListener('resize', handleResize);\n      cancelAnimationFrame(animationFrameId);\n    };\n  }, [particleColor, particleCount, minSize, maxSize, speed, connectDistance]);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    className: `absolute inset-0 w-full h-full ${className || ''}`,\n    style: {\n      backgroundColor: 'transparent'\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 287,\n    columnNumber: 5\n  }, this);\n};\n_s(SimpleSparkles, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = SimpleSparkles;\nexport default SimpleSparkles;\nvar _c;\n$RefreshReg$(_c, \"SimpleSparkles\");","map":{"version":3,"names":["React","useEffect","useRef","jsxDEV","_jsxDEV","SimpleSparkles","className","particleColor","particleCount","minSize","maxSize","speed","connectDistance","_s","canvasRef","canvas","current","ctx","getContext","alpha","willReadFrequently","particles","animationSpeed","animationFrameId","hasRenderedFirstFrame","baseColor","baseR","parseInt","slice","baseG","baseB","brightR","Math","min","brightG","brightB","resizeTimeout","handleResize","clearTimeout","setTimeout","setupCanvas","devicePixelRatio","window","pixelRatio","displayWidth","clientWidth","displayHeight","clientHeight","width","floor","height","setTransform","scale","translate","imageSmoothingEnabled","imageSmoothingQuality","createParticles","area","adjustedCount","max","i","angle","random","PI","speedFactor","push","x","y","size","speedX","cos","speedY","sin","opacity","targetOpacity","r","g","b","acceleration","maxSpeed","connectionCheckFrame","updateParticleOpacity","particle","delta","diff","lastTime","frameCount","animate","timestamp","deltaTime","clearRect","connectionsToRender","length","p","currentSpeed","sqrt","ratio","checkLimit","j","p2","dx","dy","squareDistance","distance","x1","y1","x2","y2","opacity1","opacity2","globalCompositeOperation","conn","beginPath","connectionOpacity","gradient","createLinearGradient","addColorStop","strokeStyle","lineWidth","moveTo","lineTo","stroke","particleFillColor","particleWhiteColor","shadowBlur","shadowColor","createRadialGradient","arc","fillStyle","fill","requestAnimationFrame","addEventListener","removeEventListener","cancelAnimationFrame","ref","style","backgroundColor","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Applications/MAMP/htdocs/IS213-TicketMaster/frontend/ticketmaster/src/components/ui/SimpleSparkles.jsx"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\n\nconst SimpleSparkles = ({ \n  className, \n  particleColor = '#57A5FF', \n  particleCount = 120, // Reduced count for better performance\n  minSize = 4,  // Slightly smaller for better performance\n  maxSize = 8,  // Slightly smaller for better performance\n  speed = 1.0,  // Reduced speed for smoother motion\n  connectDistance = 180\n}) => {\n  const canvasRef = useRef(null);\n  \n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    const ctx = canvas.getContext('2d', { alpha: true, willReadFrequently: false });\n    let particles = [];\n    let animationSpeed = 1;\n    let animationFrameId = null;\n    let hasRenderedFirstFrame = false;\n    \n    // Preprocessing color values to avoid string parsing in animation loop\n    const baseColor = particleColor;\n    const baseR = parseInt(baseColor.slice(1, 3), 16);\n    const baseG = parseInt(baseColor.slice(3, 5), 16);\n    const baseB = parseInt(baseColor.slice(5, 7), 16);\n    \n    // Brightened values (precomputed)\n    const brightR = Math.min(255, baseR + 80);\n    const brightG = Math.min(255, baseG + 80);\n    const brightB = Math.min(255, baseB + 80);\n    \n    // More smooth resize handling with debouncing\n    let resizeTimeout;\n    const handleResize = () => {\n      clearTimeout(resizeTimeout);\n      resizeTimeout = setTimeout(() => {\n        setupCanvas();\n      }, 100);\n    };\n    \n    // Setup canvas with proper scaling\n    const setupCanvas = () => {\n      const devicePixelRatio = window.devicePixelRatio || 1;\n      const pixelRatio = Math.min(devicePixelRatio, 1.5); // Cap at 1.5x for performance\n      \n      // Get display size\n      const displayWidth = canvas.clientWidth;\n      const displayHeight = canvas.clientHeight;\n      \n      // Set canvas size for HiDPI display\n      canvas.width = Math.floor(displayWidth * pixelRatio);\n      canvas.height = Math.floor(displayHeight * pixelRatio);\n      \n      // Reset transform before scaling\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.scale(pixelRatio, pixelRatio);\n      \n      // Avoid blurry lines\n      ctx.translate(0.5, 0.5);\n      \n      // Enable antialiasing for gradients\n      ctx.imageSmoothingEnabled = true;\n      ctx.imageSmoothingQuality = 'high';\n      \n      createParticles();\n    };\n    \n    // Create particles\n    const createParticles = () => {\n      particles = []; // Clear existing particles\n      \n      // Adjust particle count based on canvas size for performance\n      const area = (canvas.clientWidth * canvas.clientHeight) / 250000;\n      const adjustedCount = Math.min(particleCount, Math.max(40, Math.floor(particleCount * Math.min(1, area))));\n      \n      for (let i = 0; i < adjustedCount; i++) {\n        const angle = Math.random() * Math.PI * 2;\n        const speedFactor = (Math.random() * 0.5 + 0.5) * speed;\n        \n        particles.push({\n          x: Math.random() * canvas.clientWidth,\n          y: Math.random() * canvas.clientHeight,\n          size: Math.random() * (maxSize - minSize) + minSize,\n          speedX: Math.cos(angle) * speedFactor,\n          speedY: Math.sin(angle) * speedFactor,\n          opacity: Math.random() * 0.3 + 0.7,\n          targetOpacity: Math.random() * 0.3 + 0.7, // Target for smooth transitions\n          // Store precomputed color values\n          r: brightR,\n          g: brightG,\n          b: brightB,\n          acceleration: Math.random() * 0.008 + 0.002, // Reduced for smoother movement\n          maxSpeed: speedFactor * 1.2, // Slightly reduced max speed\n          // Add properties for optimization\n          connectionCheckFrame: i % 3 // Distribute connection checks across frames\n        });\n      }\n    };\n    \n    // Smooth opacity transitions to prevent flickering\n    const updateParticleOpacity = (particle, delta) => {\n      // Update target opacity occasionally\n      if (Math.random() < 0.03) {\n        particle.targetOpacity = Math.random() * 0.3 + 0.7;\n      }\n      \n      // Smoothly transition current opacity to target\n      const diff = particle.targetOpacity - particle.opacity;\n      particle.opacity += diff * 0.03 * (delta / 16);\n    };\n    \n    // Animation loop with consistent timing\n    let lastTime = 0;\n    let frameCount = 0;\n    \n    const animate = (timestamp) => {\n      if (!hasRenderedFirstFrame) {\n        hasRenderedFirstFrame = true;\n      }\n      \n      // Calculate delta time (with safety caps)\n      const deltaTime = lastTime ? Math.min(timestamp - lastTime, 33) : 16; // Cap at ~30fps equivalent\n      lastTime = timestamp;\n      \n      const delta = deltaTime * animationSpeed;\n      frameCount++;\n      \n      // Clear with alpha for smoother transitions\n      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);\n      \n      // Connection map for optimization\n      const connectionsToRender = [];\n      \n      // Update particle positions first\n      for (let i = 0; i < particles.length; i++) {\n        const p = particles[i];\n        \n        // Smooth opacity updates\n        updateParticleOpacity(p, delta);\n        \n        // Smoother acceleration adjustments\n        if (frameCount % 3 === 0) { // Reduced frequency for smoother movement\n          const acceleration = p.acceleration * delta;\n          p.speedX += (Math.random() - 0.5) * acceleration;\n          p.speedY += (Math.random() - 0.5) * acceleration;\n          \n          // Cap the speed\n          const currentSpeed = Math.sqrt(p.speedX * p.speedX + p.speedY * p.speedY);\n          if (currentSpeed > p.maxSpeed) {\n            const ratio = p.maxSpeed / currentSpeed;\n            p.speedX *= ratio;\n            p.speedY *= ratio;\n          }\n        }\n        \n        // Update position with delta time scaling\n        p.x += p.speedX * (delta / 16);\n        p.y += p.speedY * (delta / 16);\n        \n        // Bounce off edges with smoother transitions\n        if (p.x < 0 || p.x > canvas.clientWidth) {\n          p.speedX = -p.speedX;\n          p.x = p.x < 0 ? 0 : canvas.clientWidth;\n        }\n        if (p.y < 0 || p.y > canvas.clientHeight) {\n          p.speedY = -p.speedY;\n          p.y = p.y < 0 ? 0 : canvas.clientHeight;\n        }\n        \n        // Distribute connection checks across frames\n        if (p.connectionCheckFrame === frameCount % 3) {\n          const checkLimit = Math.min(particles.length, i + 20); // Check fewer particles\n          \n          for (let j = i + 1; j < checkLimit; j++) {\n            const p2 = particles[j];\n            \n            // Quick distance check first (square distance is faster than sqrt)\n            const dx = p.x - p2.x;\n            const dy = p.y - p2.y;\n            const squareDistance = dx * dx + dy * dy;\n            \n            if (squareDistance < connectDistance * connectDistance) {\n              const distance = Math.sqrt(squareDistance);\n              \n              if (distance < connectDistance) {\n                connectionsToRender.push({\n                  x1: p.x,\n                  y1: p.y,\n                  x2: p2.x,\n                  y2: p2.y,\n                  distance: distance,\n                  opacity1: p.opacity,\n                  opacity2: p2.opacity,\n                  r: p.r,\n                  g: p.g,\n                  b: p.b\n                });\n              }\n            }\n          }\n        }\n      }\n      \n      // Now render particles (separate from position updates)\n      // First render connections (behind particles)\n      ctx.globalCompositeOperation = 'source-over';\n      \n      // Batch render connections\n      for (let i = 0; i < connectionsToRender.length; i++) {\n        const conn = connectionsToRender[i];\n        \n        ctx.beginPath();\n        \n        // Higher base opacity for connections\n        const connectionOpacity = (1 - conn.distance / connectDistance) * 0.7;\n        \n        // Use gradient\n        const gradient = ctx.createLinearGradient(conn.x1, conn.y1, conn.x2, conn.y2);\n        gradient.addColorStop(0, `rgba(${conn.r}, ${conn.g}, ${conn.b}, ${connectionOpacity * conn.opacity1})`);\n        gradient.addColorStop(0.5, `rgba(255, 255, 255, ${connectionOpacity * 0.6})`);\n        gradient.addColorStop(1, `rgba(${conn.r}, ${conn.g}, ${conn.b}, ${connectionOpacity * conn.opacity2})`);\n        \n        ctx.strokeStyle = gradient;\n        ctx.lineWidth = 1.0; // Slightly thinner for performance\n        ctx.moveTo(conn.x1, conn.y1);\n        ctx.lineTo(conn.x2, conn.y2);\n        ctx.stroke();\n      }\n      \n      // Then render particles (on top of connections)\n      for (let i = 0; i < particles.length; i++) {\n        const p = particles[i];\n        \n        // Define colors outside the loop for reuse\n        const particleFillColor = `rgba(${p.r}, ${p.g}, ${p.b}, ${p.opacity})`;\n        const particleWhiteColor = `rgba(255, 255, 255, ${p.opacity})`;\n        \n        // Use shadow only for larger particles to reduce flicker\n        if ((i % 10 === 0) && p.size > minSize + 1) {\n          ctx.shadowBlur = 10;\n          ctx.shadowColor = particleFillColor;\n        } else {\n          ctx.shadowBlur = 0;\n        }\n        \n        // Draw particle\n        ctx.beginPath();\n        \n        // Create radial gradient\n        const gradient = ctx.createRadialGradient(\n          p.x, p.y, 0,\n          p.x, p.y, p.size\n        );\n        gradient.addColorStop(0, particleWhiteColor);\n        gradient.addColorStop(0.4, particleFillColor);\n        gradient.addColorStop(1, `rgba(${p.r}, ${p.g}, ${p.b}, 0)`);\n        \n        ctx.arc(p.x, p.y, p.size * 1.2, 0, Math.PI * 2);\n        ctx.fillStyle = gradient;\n        ctx.fill();\n      }\n      \n      ctx.shadowBlur = 0; // Reset shadow\n      \n      animationFrameId = requestAnimationFrame(animate);\n    };\n    \n    // Initialize\n    setupCanvas();\n    window.addEventListener('resize', handleResize);\n    \n    // Start animation\n    animationFrameId = requestAnimationFrame(animate);\n    \n    // Cleanup\n    return () => {\n      clearTimeout(resizeTimeout);\n      window.removeEventListener('resize', handleResize);\n      cancelAnimationFrame(animationFrameId);\n    };\n  }, [particleColor, particleCount, minSize, maxSize, speed, connectDistance]);\n  \n  return (\n    <canvas\n      ref={canvasRef}\n      className={`absolute inset-0 w-full h-full ${className || ''}`}\n      style={{ backgroundColor: 'transparent' }}\n    />\n  );\n};\n\nexport default SimpleSparkles; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}