{"ast":null,"code":"// Service Worker Registration and Communication\n\n// Helper to communicate with the service worker\nasync function sendMessageToSW(message) {\n  return new Promise((resolve, reject) => {\n    if (!navigator.serviceWorker || !navigator.serviceWorker.controller) {\n      console.error('No service worker controller found');\n      reject(new Error('No service worker controller found'));\n      return;\n    }\n    const messageChannel = new MessageChannel();\n\n    // Listen for response\n    messageChannel.port1.onmessage = event => {\n      resolve(event.data);\n    };\n\n    // Send message to service worker\n    navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\n  });\n}\n\n// Register the auth service worker\nexport async function registerAuthServiceWorker() {\n  if ('serviceWorker' in navigator) {\n    try {\n      const registration = await navigator.serviceWorker.register('/auth-service-worker.js');\n      console.log('Auth Service Worker registered with scope:', registration.scope);\n      return registration;\n    } catch (error) {\n      console.error('Service Worker registration failed:', error);\n      return null;\n    }\n  } else {\n    console.warn('Service Workers not supported');\n    return null;\n  }\n}\n\n// Store auth data in service worker\nexport async function storeAuthInSW(authData) {\n  try {\n    // Make sure we have a controller before sending messages\n    if (!navigator.serviceWorker || !navigator.serviceWorker.controller) {\n      await ensureServiceWorkerController();\n    }\n    const result = await sendMessageToSW({\n      type: 'STORE_AUTH',\n      payload: authData\n    });\n    console.log('Auth data stored in SW:', result);\n    return result.success;\n  } catch (error) {\n    console.error('Error storing auth data in SW:', error);\n    return false;\n  }\n}\n\n// Retrieve auth data from service worker\nexport async function getAuthFromSW() {\n  try {\n    // Make sure we have a controller before sending messages\n    if (!navigator.serviceWorker || !navigator.serviceWorker.controller) {\n      await ensureServiceWorkerController();\n    }\n    const result = await sendMessageToSW({\n      type: 'GET_AUTH'\n    });\n    if (result.success) {\n      console.log('Auth data retrieved from SW');\n      return result.authData;\n    }\n    return null;\n  } catch (error) {\n    console.error('Error retrieving auth data from SW:', error);\n    return null;\n  }\n}\n\n// Clear auth data from service worker\nexport async function clearAuthFromSW() {\n  try {\n    // Make sure we have a controller before sending messages\n    if (!navigator.serviceWorker || !navigator.serviceWorker.controller) {\n      await ensureServiceWorkerController();\n    }\n    const result = await sendMessageToSW({\n      type: 'CLEAR_AUTH'\n    });\n    console.log('Auth data cleared from SW:', result);\n    return result.success;\n  } catch (error) {\n    console.error('Error clearing auth data from SW:', error);\n    return false;\n  }\n}\n\n// Helper to ensure the service worker is controlling the page\nasync function ensureServiceWorkerController() {\n  // If service worker is already controlling, return\n  if (navigator.serviceWorker.controller) {\n    return navigator.serviceWorker.controller;\n  }\n\n  // Otherwise, register and wait for it to take control\n  await registerAuthServiceWorker();\n\n  // Wait for the service worker to take control\n  return new Promise(resolve => {\n    navigator.serviceWorker.addEventListener('controllerchange', () => {\n      resolve(navigator.serviceWorker.controller);\n    });\n\n    // If after 3 seconds the service worker hasn't taken control, resolve anyway\n    setTimeout(() => {\n      resolve(navigator.serviceWorker.controller);\n    }, 3000);\n  });\n}","map":{"version":3,"names":["sendMessageToSW","message","Promise","resolve","reject","navigator","serviceWorker","controller","console","error","Error","messageChannel","MessageChannel","port1","onmessage","event","data","postMessage","port2","registerAuthServiceWorker","registration","register","log","scope","warn","storeAuthInSW","authData","ensureServiceWorkerController","result","type","payload","success","getAuthFromSW","clearAuthFromSW","addEventListener","setTimeout"],"sources":["/Applications/MAMP/htdocs/ticketmaster/src/services/authServiceWorker.js"],"sourcesContent":["// Service Worker Registration and Communication\n\n// Helper to communicate with the service worker\nasync function sendMessageToSW(message) {\n  return new Promise((resolve, reject) => {\n    if (!navigator.serviceWorker || !navigator.serviceWorker.controller) {\n      console.error('No service worker controller found');\n      reject(new Error('No service worker controller found'));\n      return;\n    }\n    \n    const messageChannel = new MessageChannel();\n    \n    // Listen for response\n    messageChannel.port1.onmessage = (event) => {\n      resolve(event.data);\n    };\n    \n    // Send message to service worker\n    navigator.serviceWorker.controller.postMessage(message, [messageChannel.port2]);\n  });\n}\n\n// Register the auth service worker\nexport async function registerAuthServiceWorker() {\n  if ('serviceWorker' in navigator) {\n    try {\n      const registration = await navigator.serviceWorker.register('/auth-service-worker.js');\n      console.log('Auth Service Worker registered with scope:', registration.scope);\n      return registration;\n    } catch (error) {\n      console.error('Service Worker registration failed:', error);\n      return null;\n    }\n  } else {\n    console.warn('Service Workers not supported');\n    return null;\n  }\n}\n\n// Store auth data in service worker\nexport async function storeAuthInSW(authData) {\n  try {\n    // Make sure we have a controller before sending messages\n    if (!navigator.serviceWorker || !navigator.serviceWorker.controller) {\n      await ensureServiceWorkerController();\n    }\n    \n    const result = await sendMessageToSW({\n      type: 'STORE_AUTH',\n      payload: authData\n    });\n    \n    console.log('Auth data stored in SW:', result);\n    return result.success;\n  } catch (error) {\n    console.error('Error storing auth data in SW:', error);\n    return false;\n  }\n}\n\n// Retrieve auth data from service worker\nexport async function getAuthFromSW() {\n  try {\n    // Make sure we have a controller before sending messages\n    if (!navigator.serviceWorker || !navigator.serviceWorker.controller) {\n      await ensureServiceWorkerController();\n    }\n    \n    const result = await sendMessageToSW({\n      type: 'GET_AUTH'\n    });\n    \n    if (result.success) {\n      console.log('Auth data retrieved from SW');\n      return result.authData;\n    }\n    return null;\n  } catch (error) {\n    console.error('Error retrieving auth data from SW:', error);\n    return null;\n  }\n}\n\n// Clear auth data from service worker\nexport async function clearAuthFromSW() {\n  try {\n    // Make sure we have a controller before sending messages\n    if (!navigator.serviceWorker || !navigator.serviceWorker.controller) {\n      await ensureServiceWorkerController();\n    }\n    \n    const result = await sendMessageToSW({\n      type: 'CLEAR_AUTH'\n    });\n    \n    console.log('Auth data cleared from SW:', result);\n    return result.success;\n  } catch (error) {\n    console.error('Error clearing auth data from SW:', error);\n    return false;\n  }\n}\n\n// Helper to ensure the service worker is controlling the page\nasync function ensureServiceWorkerController() {\n  // If service worker is already controlling, return\n  if (navigator.serviceWorker.controller) {\n    return navigator.serviceWorker.controller;\n  }\n  \n  // Otherwise, register and wait for it to take control\n  await registerAuthServiceWorker();\n  \n  // Wait for the service worker to take control\n  return new Promise((resolve) => {\n    navigator.serviceWorker.addEventListener('controllerchange', () => {\n      resolve(navigator.serviceWorker.controller);\n    });\n    \n    // If after 3 seconds the service worker hasn't taken control, resolve anyway\n    setTimeout(() => {\n      resolve(navigator.serviceWorker.controller);\n    }, 3000);\n  });\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}