{"ast":null,"code":"var _jsxFileName = \"/Applications/MAMP/htdocs/ticketmaster/src/components/ui/SimpleSparkles.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SimpleSparkles = ({\n  className,\n  particleColor = '#57A5FF',\n  particleCount = 120,\n  // Reduced count for better performance\n  minSize = 5,\n  maxSize = 10,\n  speed = 1.8,\n  connectDistance = 180\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d', {\n      alpha: true\n    });\n    const particles = [];\n    let animationSpeed = 1;\n    let animationFrameId = null;\n    let lastDrawTime = 0;\n    const targetFPS = 30; // Cap at 30fps for better performance\n    const frameInterval = 1000 / targetFPS;\n\n    // Preprocessing color values to avoid string parsing in animation loop\n    const baseColor = particleColor;\n    const baseR = parseInt(baseColor.slice(1, 3), 16);\n    const baseG = parseInt(baseColor.slice(3, 5), 16);\n    const baseB = parseInt(baseColor.slice(5, 7), 16);\n\n    // Brightened values (precomputed)\n    const brightR = Math.min(255, baseR + 80);\n    const brightG = Math.min(255, baseG + 80);\n    const brightB = Math.min(255, baseB + 80);\n\n    // Resize handler\n    const handleResize = () => {\n      // Use logical size for canvas but scale rendering\n      const pixelRatio = Math.min(window.devicePixelRatio, 2); // Cap at 2x for performance\n\n      canvas.width = canvas.offsetWidth * pixelRatio;\n      canvas.height = canvas.offsetHeight * pixelRatio;\n\n      // Scale context according to pixelRatio\n      ctx.scale(pixelRatio, pixelRatio);\n      createParticles();\n    };\n\n    // Create particles\n    const createParticles = () => {\n      particles.length = 0;\n\n      // Adjust particle count based on canvas size for performance\n      const area = canvas.offsetWidth * canvas.offsetHeight / 250000;\n      const adjustedCount = Math.min(particleCount, Math.max(50, Math.floor(particleCount * Math.min(1, area))));\n      for (let i = 0; i < adjustedCount; i++) {\n        const angle = Math.random() * Math.PI * 2;\n        const speedFactor = (Math.random() * 0.5 + 0.5) * speed;\n        particles.push({\n          x: Math.random() * canvas.offsetWidth,\n          y: Math.random() * canvas.offsetHeight,\n          size: Math.random() * (maxSize - minSize) + minSize,\n          speedX: Math.cos(angle) * speedFactor,\n          speedY: Math.sin(angle) * speedFactor,\n          opacity: Math.random() * 0.3 + 0.7,\n          // Store precomputed color values\n          r: brightR,\n          g: brightG,\n          b: brightB,\n          acceleration: Math.random() * 0.01 + 0.005,\n          maxSpeed: speedFactor * 1.5,\n          // Add properties for optimization\n          lastOpacityUpdate: 0,\n          opacityUpdateInterval: 3,\n          // Only update opacity every 3 frames\n          connectionCheckFrame: i % 3 // Distribute connection checks across frames\n        });\n      }\n    };\n\n    // Efficient shimmer effect\n    const updateParticleOpacity = (particle, frameCount) => {\n      // Only update opacity occasionally, not every frame\n      if (frameCount % particle.opacityUpdateInterval !== 0) return;\n      particle.opacity += (Math.random() - 0.5) * 0.1;\n      particle.opacity = Math.max(0.6, Math.min(1, particle.opacity));\n    };\n\n    // Animation loop with time-based updates and frame skipping\n    let lastTime = 0;\n    let frameCount = 0;\n    const animate = timestamp => {\n      // Skip frames if needed for performance\n      const elapsed = timestamp - lastDrawTime;\n      if (elapsed < frameInterval) {\n        animationFrameId = requestAnimationFrame(animate);\n        return;\n      }\n\n      // Calculate delta time\n      const deltaTime = timestamp - lastTime;\n      lastTime = timestamp;\n      lastDrawTime = timestamp - elapsed % frameInterval;\n      const delta = Math.min(deltaTime, 30) * animationSpeed;\n      frameCount++;\n      ctx.clearRect(0, 0, canvas.offsetWidth, canvas.offsetHeight);\n\n      // Connection map for optimization\n      const connectionsToRender = [];\n\n      // Update particle positions first\n      for (let i = 0; i < particles.length; i++) {\n        const p = particles[i];\n\n        // Update opacity less frequently\n        updateParticleOpacity(p, frameCount);\n\n        // Less frequent acceleration adjustments\n        if (frameCount % 2 === 0) {\n          const acceleration = p.acceleration * delta;\n          p.speedX += (Math.random() - 0.5) * acceleration;\n          p.speedY += (Math.random() - 0.5) * acceleration;\n\n          // Cap the speed\n          const currentSpeed = Math.sqrt(p.speedX * p.speedX + p.speedY * p.speedY);\n          if (currentSpeed > p.maxSpeed) {\n            p.speedX = p.speedX / currentSpeed * p.maxSpeed;\n            p.speedY = p.speedY / currentSpeed * p.maxSpeed;\n          }\n        }\n\n        // Update position\n        p.x += p.speedX * (delta / 16);\n        p.y += p.speedY * (delta / 16);\n\n        // Bounce off edges\n        if (p.x < 0 || p.x > canvas.offsetWidth) {\n          p.speedX = -p.speedX * (0.9 + Math.random() * 0.2);\n          p.x = Math.max(0, Math.min(canvas.offsetWidth, p.x));\n        }\n        if (p.y < 0 || p.y > canvas.offsetHeight) {\n          p.speedY = -p.speedY * (0.9 + Math.random() * 0.2);\n          p.y = Math.max(0, Math.min(canvas.offsetHeight, p.y));\n        }\n\n        // Distribute connection checks across frames (only 1/3 particles per frame)\n        if (p.connectionCheckFrame === frameCount % 3) {\n          const checkLimit = Math.min(particles.length, i + 25); // Check fewer particles\n\n          for (let j = i + 1; j < checkLimit; j++) {\n            const p2 = particles[j];\n\n            // Quick distance check first (square distance is faster than sqrt)\n            const dx = p.x - p2.x;\n            const dy = p.y - p2.y;\n            const squareDistance = dx * dx + dy * dy;\n            if (squareDistance < connectDistance * connectDistance) {\n              const distance = Math.sqrt(squareDistance);\n              if (distance < connectDistance) {\n                connectionsToRender.push({\n                  x1: p.x,\n                  y1: p.y,\n                  x2: p2.x,\n                  y2: p2.y,\n                  distance: distance,\n                  opacity1: p.opacity,\n                  opacity2: p2.opacity,\n                  r: p.r,\n                  g: p.g,\n                  b: p.b\n                });\n              }\n            }\n          }\n        }\n      }\n\n      // Now render particles (separate from position updates)\n      for (let i = 0; i < particles.length; i++) {\n        const p = particles[i];\n\n        // Define colors outside the loop for reuse\n        const particleFillColor = `rgba(${p.r}, ${p.g}, ${p.b}, ${p.opacity})`;\n\n        // Turn off shadow for most particles\n        if (i % 5 === 0) {\n          // Only 20% of particles get shadow\n          ctx.shadowBlur = 15;\n          ctx.shadowColor = particleFillColor;\n        } else {\n          ctx.shadowBlur = 0;\n        }\n\n        // Draw particle\n        ctx.beginPath();\n\n        // Create radial gradient\n        const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);\n        gradient.addColorStop(0, 'rgba(255, 255, 255, ' + p.opacity + ')');\n        gradient.addColorStop(0.4, particleFillColor);\n        gradient.addColorStop(1, `rgba(${p.r}, ${p.g}, ${p.b}, 0)`);\n        ctx.arc(p.x, p.y, p.size * 1.5, 0, Math.PI * 2);\n        ctx.fillStyle = gradient;\n        ctx.fill();\n      }\n\n      // Turn off shadow for connections\n      ctx.shadowBlur = 0;\n\n      // Batch render connections\n      for (let i = 0; i < connectionsToRender.length; i++) {\n        const conn = connectionsToRender[i];\n        ctx.beginPath();\n\n        // Higher base opacity for connections\n        const connectionOpacity = (1 - conn.distance / connectDistance) * 0.8;\n\n        // Use gradient\n        const gradient = ctx.createLinearGradient(conn.x1, conn.y1, conn.x2, conn.y2);\n        gradient.addColorStop(0, `rgba(${conn.r}, ${conn.g}, ${conn.b}, ${connectionOpacity * conn.opacity1})`);\n        gradient.addColorStop(0.5, `rgba(255, 255, 255, ${connectionOpacity * 0.7})`);\n        gradient.addColorStop(1, `rgba(${conn.r}, ${conn.g}, ${conn.b}, ${connectionOpacity * conn.opacity2})`);\n        ctx.strokeStyle = gradient;\n        ctx.lineWidth = 1.2;\n        ctx.moveTo(conn.x1, conn.y1);\n        ctx.lineTo(conn.x2, conn.y2);\n        ctx.stroke();\n      }\n      animationFrameId = requestAnimationFrame(animate);\n    };\n\n    // Initialize\n    handleResize();\n    window.addEventListener('resize', handleResize);\n\n    // Start animation\n    animationFrameId = requestAnimationFrame(animate);\n\n    // Cleanup\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      cancelAnimationFrame(animationFrameId);\n    };\n  }, [particleColor, particleCount, minSize, maxSize, speed, connectDistance]);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    className: `absolute inset-0 w-full h-full ${className || ''}`,\n    style: {\n      backgroundColor: 'transparent'\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 263,\n    columnNumber: 5\n  }, this);\n};\n_s(SimpleSparkles, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = SimpleSparkles;\nexport default SimpleSparkles;\nvar _c;\n$RefreshReg$(_c, \"SimpleSparkles\");","map":{"version":3,"names":["React","useEffect","useRef","jsxDEV","_jsxDEV","SimpleSparkles","className","particleColor","particleCount","minSize","maxSize","speed","connectDistance","_s","canvasRef","canvas","current","ctx","getContext","alpha","particles","animationSpeed","animationFrameId","lastDrawTime","targetFPS","frameInterval","baseColor","baseR","parseInt","slice","baseG","baseB","brightR","Math","min","brightG","brightB","handleResize","pixelRatio","window","devicePixelRatio","width","offsetWidth","height","offsetHeight","scale","createParticles","length","area","adjustedCount","max","floor","i","angle","random","PI","speedFactor","push","x","y","size","speedX","cos","speedY","sin","opacity","r","g","b","acceleration","maxSpeed","lastOpacityUpdate","opacityUpdateInterval","connectionCheckFrame","updateParticleOpacity","particle","frameCount","lastTime","animate","timestamp","elapsed","requestAnimationFrame","deltaTime","delta","clearRect","connectionsToRender","p","currentSpeed","sqrt","checkLimit","j","p2","dx","dy","squareDistance","distance","x1","y1","x2","y2","opacity1","opacity2","particleFillColor","shadowBlur","shadowColor","beginPath","gradient","createRadialGradient","addColorStop","arc","fillStyle","fill","conn","connectionOpacity","createLinearGradient","strokeStyle","lineWidth","moveTo","lineTo","stroke","addEventListener","removeEventListener","cancelAnimationFrame","ref","style","backgroundColor","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Applications/MAMP/htdocs/ticketmaster/src/components/ui/SimpleSparkles.jsx"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\n\nconst SimpleSparkles = ({ \n  className, \n  particleColor = '#57A5FF', \n  particleCount = 120, // Reduced count for better performance\n  minSize = 5,\n  maxSize = 10, \n  speed = 1.8,\n  connectDistance = 180\n}) => {\n  const canvasRef = useRef(null);\n  \n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    const ctx = canvas.getContext('2d', { alpha: true });\n    const particles = [];\n    let animationSpeed = 1;\n    let animationFrameId = null;\n    let lastDrawTime = 0;\n    const targetFPS = 30; // Cap at 30fps for better performance\n    const frameInterval = 1000 / targetFPS;\n    \n    // Preprocessing color values to avoid string parsing in animation loop\n    const baseColor = particleColor;\n    const baseR = parseInt(baseColor.slice(1, 3), 16);\n    const baseG = parseInt(baseColor.slice(3, 5), 16);\n    const baseB = parseInt(baseColor.slice(5, 7), 16);\n    \n    // Brightened values (precomputed)\n    const brightR = Math.min(255, baseR + 80);\n    const brightG = Math.min(255, baseG + 80);\n    const brightB = Math.min(255, baseB + 80);\n    \n    // Resize handler\n    const handleResize = () => {\n      // Use logical size for canvas but scale rendering\n      const pixelRatio = Math.min(window.devicePixelRatio, 2); // Cap at 2x for performance\n      \n      canvas.width = canvas.offsetWidth * pixelRatio;\n      canvas.height = canvas.offsetHeight * pixelRatio;\n      \n      // Scale context according to pixelRatio\n      ctx.scale(pixelRatio, pixelRatio);\n      \n      createParticles();\n    };\n    \n    // Create particles\n    const createParticles = () => {\n      particles.length = 0;\n      \n      // Adjust particle count based on canvas size for performance\n      const area = (canvas.offsetWidth * canvas.offsetHeight) / 250000;\n      const adjustedCount = Math.min(particleCount, Math.max(50, Math.floor(particleCount * Math.min(1, area))));\n      \n      for (let i = 0; i < adjustedCount; i++) {\n        const angle = Math.random() * Math.PI * 2;\n        const speedFactor = (Math.random() * 0.5 + 0.5) * speed;\n        \n        particles.push({\n          x: Math.random() * canvas.offsetWidth,\n          y: Math.random() * canvas.offsetHeight,\n          size: Math.random() * (maxSize - minSize) + minSize,\n          speedX: Math.cos(angle) * speedFactor,\n          speedY: Math.sin(angle) * speedFactor,\n          opacity: Math.random() * 0.3 + 0.7,\n          // Store precomputed color values\n          r: brightR,\n          g: brightG,\n          b: brightB,\n          acceleration: Math.random() * 0.01 + 0.005,\n          maxSpeed: speedFactor * 1.5,\n          // Add properties for optimization\n          lastOpacityUpdate: 0,\n          opacityUpdateInterval: 3, // Only update opacity every 3 frames\n          connectionCheckFrame: i % 3 // Distribute connection checks across frames\n        });\n      }\n    };\n    \n    // Efficient shimmer effect\n    const updateParticleOpacity = (particle, frameCount) => {\n      // Only update opacity occasionally, not every frame\n      if (frameCount % particle.opacityUpdateInterval !== 0) return;\n      \n      particle.opacity += (Math.random() - 0.5) * 0.1;\n      particle.opacity = Math.max(0.6, Math.min(1, particle.opacity));\n    };\n    \n    // Animation loop with time-based updates and frame skipping\n    let lastTime = 0;\n    let frameCount = 0;\n    \n    const animate = (timestamp) => {\n      // Skip frames if needed for performance\n      const elapsed = timestamp - lastDrawTime;\n      \n      if (elapsed < frameInterval) {\n        animationFrameId = requestAnimationFrame(animate);\n        return;\n      }\n      \n      // Calculate delta time\n      const deltaTime = timestamp - lastTime;\n      lastTime = timestamp;\n      lastDrawTime = timestamp - (elapsed % frameInterval);\n      \n      const delta = Math.min(deltaTime, 30) * animationSpeed;\n      frameCount++;\n      \n      ctx.clearRect(0, 0, canvas.offsetWidth, canvas.offsetHeight);\n      \n      // Connection map for optimization\n      const connectionsToRender = [];\n      \n      // Update particle positions first\n      for (let i = 0; i < particles.length; i++) {\n        const p = particles[i];\n        \n        // Update opacity less frequently\n        updateParticleOpacity(p, frameCount);\n        \n        // Less frequent acceleration adjustments\n        if (frameCount % 2 === 0) {\n          const acceleration = p.acceleration * delta;\n          p.speedX += (Math.random() - 0.5) * acceleration;\n          p.speedY += (Math.random() - 0.5) * acceleration;\n          \n          // Cap the speed\n          const currentSpeed = Math.sqrt(p.speedX * p.speedX + p.speedY * p.speedY);\n          if (currentSpeed > p.maxSpeed) {\n            p.speedX = (p.speedX / currentSpeed) * p.maxSpeed;\n            p.speedY = (p.speedY / currentSpeed) * p.maxSpeed;\n          }\n        }\n        \n        // Update position\n        p.x += p.speedX * (delta / 16);\n        p.y += p.speedY * (delta / 16);\n        \n        // Bounce off edges\n        if (p.x < 0 || p.x > canvas.offsetWidth) {\n          p.speedX = -p.speedX * (0.9 + Math.random() * 0.2);\n          p.x = Math.max(0, Math.min(canvas.offsetWidth, p.x));\n        }\n        if (p.y < 0 || p.y > canvas.offsetHeight) {\n          p.speedY = -p.speedY * (0.9 + Math.random() * 0.2);\n          p.y = Math.max(0, Math.min(canvas.offsetHeight, p.y));\n        }\n        \n        // Distribute connection checks across frames (only 1/3 particles per frame)\n        if (p.connectionCheckFrame === frameCount % 3) {\n          const checkLimit = Math.min(particles.length, i + 25); // Check fewer particles\n          \n          for (let j = i + 1; j < checkLimit; j++) {\n            const p2 = particles[j];\n            \n            // Quick distance check first (square distance is faster than sqrt)\n            const dx = p.x - p2.x;\n            const dy = p.y - p2.y;\n            const squareDistance = dx * dx + dy * dy;\n            \n            if (squareDistance < connectDistance * connectDistance) {\n              const distance = Math.sqrt(squareDistance);\n              \n              if (distance < connectDistance) {\n                connectionsToRender.push({\n                  x1: p.x,\n                  y1: p.y,\n                  x2: p2.x,\n                  y2: p2.y,\n                  distance: distance,\n                  opacity1: p.opacity,\n                  opacity2: p2.opacity,\n                  r: p.r,\n                  g: p.g,\n                  b: p.b\n                });\n              }\n            }\n          }\n        }\n      }\n      \n      // Now render particles (separate from position updates)\n      for (let i = 0; i < particles.length; i++) {\n        const p = particles[i];\n        \n        // Define colors outside the loop for reuse\n        const particleFillColor = `rgba(${p.r}, ${p.g}, ${p.b}, ${p.opacity})`;\n        \n        // Turn off shadow for most particles\n        if (i % 5 === 0) { // Only 20% of particles get shadow\n          ctx.shadowBlur = 15;\n          ctx.shadowColor = particleFillColor;\n        } else {\n          ctx.shadowBlur = 0;\n        }\n        \n        // Draw particle\n        ctx.beginPath();\n        \n        // Create radial gradient\n        const gradient = ctx.createRadialGradient(\n          p.x, p.y, 0,\n          p.x, p.y, p.size\n        );\n        gradient.addColorStop(0, 'rgba(255, 255, 255, ' + p.opacity + ')');\n        gradient.addColorStop(0.4, particleFillColor);\n        gradient.addColorStop(1, `rgba(${p.r}, ${p.g}, ${p.b}, 0)`);\n        \n        ctx.arc(p.x, p.y, p.size * 1.5, 0, Math.PI * 2);\n        ctx.fillStyle = gradient;\n        ctx.fill();\n      }\n      \n      // Turn off shadow for connections\n      ctx.shadowBlur = 0;\n      \n      // Batch render connections\n      for (let i = 0; i < connectionsToRender.length; i++) {\n        const conn = connectionsToRender[i];\n        \n        ctx.beginPath();\n        \n        // Higher base opacity for connections\n        const connectionOpacity = (1 - conn.distance / connectDistance) * 0.8;\n        \n        // Use gradient\n        const gradient = ctx.createLinearGradient(conn.x1, conn.y1, conn.x2, conn.y2);\n        gradient.addColorStop(0, `rgba(${conn.r}, ${conn.g}, ${conn.b}, ${connectionOpacity * conn.opacity1})`);\n        gradient.addColorStop(0.5, `rgba(255, 255, 255, ${connectionOpacity * 0.7})`);\n        gradient.addColorStop(1, `rgba(${conn.r}, ${conn.g}, ${conn.b}, ${connectionOpacity * conn.opacity2})`);\n        \n        ctx.strokeStyle = gradient;\n        ctx.lineWidth = 1.2;\n        ctx.moveTo(conn.x1, conn.y1);\n        ctx.lineTo(conn.x2, conn.y2);\n        ctx.stroke();\n      }\n      \n      animationFrameId = requestAnimationFrame(animate);\n    };\n    \n    // Initialize\n    handleResize();\n    window.addEventListener('resize', handleResize);\n    \n    // Start animation\n    animationFrameId = requestAnimationFrame(animate);\n    \n    // Cleanup\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      cancelAnimationFrame(animationFrameId);\n    };\n  }, [particleColor, particleCount, minSize, maxSize, speed, connectDistance]);\n  \n  return (\n    <canvas\n      ref={canvasRef}\n      className={`absolute inset-0 w-full h-full ${className || ''}`}\n      style={{ backgroundColor: 'transparent' }}\n    />\n  );\n};\n\nexport default SimpleSparkles; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}