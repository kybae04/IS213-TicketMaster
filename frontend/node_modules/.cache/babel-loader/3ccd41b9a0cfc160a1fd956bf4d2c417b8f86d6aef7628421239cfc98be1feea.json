{"ast":null,"code":"var _jsxFileName = \"/Applications/MAMP/htdocs/ticketmaster/src/components/ui/SimpleSparkles.jsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef } from 'react';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SimpleSparkles = ({\n  className,\n  particleColor = '#57A5FF',\n  particleCount = 200,\n  minSize = 0.8,\n  maxSize = 1.6,\n  speed = 1.8,\n  // Doubled but with additional improvements below\n  connectDistance = 150\n}) => {\n  _s();\n  const canvasRef = useRef(null);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    const particles = [];\n    let animationSpeed = 1; // Animation speed multiplier\n\n    // Resize handler\n    const handleResize = () => {\n      canvas.width = canvas.offsetWidth;\n      canvas.height = canvas.offsetHeight;\n      createParticles();\n    };\n\n    // Create particles\n    const createParticles = () => {\n      particles.length = 0;\n      for (let i = 0; i < particleCount; i++) {\n        const angle = Math.random() * Math.PI * 2; // Random direction\n        const speedFactor = (Math.random() * 0.5 + 0.5) * speed; // Variable speed\n\n        particles.push({\n          x: Math.random() * canvas.width,\n          y: Math.random() * canvas.height,\n          size: Math.random() * (maxSize - minSize) + minSize,\n          // Use angle-based velocity for more dynamic movement\n          speedX: Math.cos(angle) * speedFactor,\n          speedY: Math.sin(angle) * speedFactor,\n          opacity: Math.random() * 0.5 + 0.5,\n          hue: Math.random() * 40 - 20,\n          // Add acceleration for more interesting movement\n          acceleration: Math.random() * 0.01 + 0.005,\n          maxSpeed: speedFactor * 1.5 // Cap on max speed\n        });\n      }\n    };\n\n    // Create shimmer effect with faster updates\n    const updateParticleOpacity = particle => {\n      particle.opacity += (Math.random() - 0.5) * 0.1; // Increased change amount\n      particle.opacity = Math.max(0.4, Math.min(1, particle.opacity));\n    };\n\n    // Animation loop with time-based updates\n    let lastTime = 0;\n    const animate = timestamp => {\n      // Calculate delta time for smooth animation regardless of frame rate\n      const deltaTime = timestamp - lastTime;\n      lastTime = timestamp;\n\n      // Limit delta to prevent huge jumps\n      const delta = Math.min(deltaTime, 30) * animationSpeed;\n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n      // Draw and update particles\n      for (let i = 0; i < particles.length; i++) {\n        const p = particles[i];\n\n        // Update opacity for shimmer effect\n        updateParticleOpacity(p);\n\n        // Get color with hue variation\n        const baseColor = particleColor;\n        let r = parseInt(baseColor.slice(1, 3), 16);\n        let g = parseInt(baseColor.slice(3, 5), 16);\n        let b = parseInt(baseColor.slice(5, 7), 16);\n\n        // Brighten particles\n        r = Math.min(255, r + 30);\n        g = Math.min(255, g + 30);\n        b = Math.min(255, b + 30);\n\n        // Apply particle's hue variation and opacity\n        const particleFillColor = `rgba(${r}, ${g}, ${b}, ${p.opacity})`;\n\n        // Draw particle\n        ctx.beginPath();\n        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);\n        ctx.fillStyle = particleFillColor;\n        ctx.fill();\n\n        // Add glow effect\n        ctx.shadowBlur = 10;\n        ctx.shadowColor = particleFillColor;\n\n        // Apply acceleration to create more dynamic movement\n        const acceleration = p.acceleration * delta;\n        p.speedX += (Math.random() - 0.5) * acceleration;\n        p.speedY += (Math.random() - 0.5) * acceleration;\n\n        // Cap the speed to prevent particles from moving too fast\n        const currentSpeed = Math.sqrt(p.speedX * p.speedX + p.speedY * p.speedY);\n        if (currentSpeed > p.maxSpeed) {\n          p.speedX = p.speedX / currentSpeed * p.maxSpeed;\n          p.speedY = p.speedY / currentSpeed * p.maxSpeed;\n        }\n\n        // Update position using delta time for smooth animation\n        p.x += p.speedX * (delta / 16); // Normalize to 60fps\n        p.y += p.speedY * (delta / 16);\n\n        // Bounce off edges with slight randomization for more natural movement\n        if (p.x < 0 || p.x > canvas.width) {\n          p.speedX = -p.speedX * (0.9 + Math.random() * 0.2);\n          p.x = Math.max(0, Math.min(canvas.width, p.x)); // Keep within bounds\n        }\n        if (p.y < 0 || p.y > canvas.height) {\n          p.speedY = -p.speedY * (0.9 + Math.random() * 0.2);\n          p.y = Math.max(0, Math.min(canvas.height, p.y)); // Keep within bounds\n        }\n\n        // Only connect to a subset of nearby particles for performance with many particles\n        if (i % 3 === 0) {\n          // Only check connections for 1/3 of particles\n          for (let j = i + 1; j < Math.min(particles.length, i + 30); j++) {\n            const p2 = particles[j];\n            const distance = Math.sqrt(Math.pow(p.x - p2.x, 2) + Math.pow(p.y - p2.y, 2));\n            if (distance < connectDistance) {\n              ctx.beginPath();\n              // Use gradient for connections\n              const gradient = ctx.createLinearGradient(p.x, p.y, p2.x, p2.y);\n              gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${(1 - distance / connectDistance) * 0.5 * p.opacity})`);\n              gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, ${(1 - distance / connectDistance) * 0.5 * p2.opacity})`);\n              ctx.strokeStyle = gradient;\n              ctx.lineWidth = 0.6;\n              ctx.moveTo(p.x, p.y);\n              ctx.lineTo(p2.x, p2.y);\n              ctx.stroke();\n            }\n          }\n        }\n      }\n      ctx.shadowBlur = 0; // Reset shadow for performance\n      requestAnimationFrame(animate);\n    };\n\n    // Initialize\n    handleResize();\n    window.addEventListener('resize', handleResize);\n\n    // Start animation\n    const animationId = requestAnimationFrame(animate);\n\n    // Cleanup\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      cancelAnimationFrame(animationId);\n    };\n  }, [particleColor, particleCount, minSize, maxSize, speed, connectDistance]);\n  return /*#__PURE__*/_jsxDEV(\"canvas\", {\n    ref: canvasRef,\n    className: `absolute inset-0 w-full h-full ${className || ''}`,\n    style: {\n      backgroundColor: 'transparent'\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 171,\n    columnNumber: 5\n  }, this);\n};\n_s(SimpleSparkles, \"UJgi7ynoup7eqypjnwyX/s32POg=\");\n_c = SimpleSparkles;\nexport default SimpleSparkles;\nvar _c;\n$RefreshReg$(_c, \"SimpleSparkles\");","map":{"version":3,"names":["React","useEffect","useRef","jsxDEV","_jsxDEV","SimpleSparkles","className","particleColor","particleCount","minSize","maxSize","speed","connectDistance","_s","canvasRef","canvas","current","ctx","getContext","particles","animationSpeed","handleResize","width","offsetWidth","height","offsetHeight","createParticles","length","i","angle","Math","random","PI","speedFactor","push","x","y","size","speedX","cos","speedY","sin","opacity","hue","acceleration","maxSpeed","updateParticleOpacity","particle","max","min","lastTime","animate","timestamp","deltaTime","delta","clearRect","p","baseColor","r","parseInt","slice","g","b","particleFillColor","beginPath","arc","fillStyle","fill","shadowBlur","shadowColor","currentSpeed","sqrt","j","p2","distance","pow","gradient","createLinearGradient","addColorStop","strokeStyle","lineWidth","moveTo","lineTo","stroke","requestAnimationFrame","window","addEventListener","animationId","removeEventListener","cancelAnimationFrame","ref","style","backgroundColor","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Applications/MAMP/htdocs/ticketmaster/src/components/ui/SimpleSparkles.jsx"],"sourcesContent":["import React, { useEffect, useRef } from 'react';\n\nconst SimpleSparkles = ({ \n  className, \n  particleColor = '#57A5FF', \n  particleCount = 200, \n  minSize = 0.8,\n  maxSize = 1.6, \n  speed = 1.8,  // Doubled but with additional improvements below\n  connectDistance = 150\n}) => {\n  const canvasRef = useRef(null);\n  \n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    \n    const ctx = canvas.getContext('2d');\n    const particles = [];\n    let animationSpeed = 1; // Animation speed multiplier\n    \n    // Resize handler\n    const handleResize = () => {\n      canvas.width = canvas.offsetWidth;\n      canvas.height = canvas.offsetHeight;\n      createParticles();\n    };\n    \n    // Create particles\n    const createParticles = () => {\n      particles.length = 0;\n      for (let i = 0; i < particleCount; i++) {\n        const angle = Math.random() * Math.PI * 2; // Random direction\n        const speedFactor = (Math.random() * 0.5 + 0.5) * speed; // Variable speed\n        \n        particles.push({\n          x: Math.random() * canvas.width,\n          y: Math.random() * canvas.height,\n          size: Math.random() * (maxSize - minSize) + minSize,\n          // Use angle-based velocity for more dynamic movement\n          speedX: Math.cos(angle) * speedFactor,\n          speedY: Math.sin(angle) * speedFactor,\n          opacity: Math.random() * 0.5 + 0.5,\n          hue: Math.random() * 40 - 20,\n          // Add acceleration for more interesting movement\n          acceleration: Math.random() * 0.01 + 0.005,\n          maxSpeed: speedFactor * 1.5 // Cap on max speed\n        });\n      }\n    };\n    \n    // Create shimmer effect with faster updates\n    const updateParticleOpacity = (particle) => {\n      particle.opacity += (Math.random() - 0.5) * 0.1; // Increased change amount\n      particle.opacity = Math.max(0.4, Math.min(1, particle.opacity));\n    };\n    \n    // Animation loop with time-based updates\n    let lastTime = 0;\n    const animate = (timestamp) => {\n      // Calculate delta time for smooth animation regardless of frame rate\n      const deltaTime = timestamp - lastTime;\n      lastTime = timestamp;\n      \n      // Limit delta to prevent huge jumps\n      const delta = Math.min(deltaTime, 30) * animationSpeed;\n      \n      ctx.clearRect(0, 0, canvas.width, canvas.height);\n      \n      // Draw and update particles\n      for (let i = 0; i < particles.length; i++) {\n        const p = particles[i];\n        \n        // Update opacity for shimmer effect\n        updateParticleOpacity(p);\n        \n        // Get color with hue variation\n        const baseColor = particleColor;\n        let r = parseInt(baseColor.slice(1, 3), 16);\n        let g = parseInt(baseColor.slice(3, 5), 16);\n        let b = parseInt(baseColor.slice(5, 7), 16);\n        \n        // Brighten particles\n        r = Math.min(255, r + 30);\n        g = Math.min(255, g + 30);\n        b = Math.min(255, b + 30);\n        \n        // Apply particle's hue variation and opacity\n        const particleFillColor = `rgba(${r}, ${g}, ${b}, ${p.opacity})`;\n        \n        // Draw particle\n        ctx.beginPath();\n        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);\n        ctx.fillStyle = particleFillColor;\n        ctx.fill();\n        \n        // Add glow effect\n        ctx.shadowBlur = 10;\n        ctx.shadowColor = particleFillColor;\n        \n        // Apply acceleration to create more dynamic movement\n        const acceleration = p.acceleration * delta;\n        p.speedX += (Math.random() - 0.5) * acceleration;\n        p.speedY += (Math.random() - 0.5) * acceleration;\n        \n        // Cap the speed to prevent particles from moving too fast\n        const currentSpeed = Math.sqrt(p.speedX * p.speedX + p.speedY * p.speedY);\n        if (currentSpeed > p.maxSpeed) {\n          p.speedX = (p.speedX / currentSpeed) * p.maxSpeed;\n          p.speedY = (p.speedY / currentSpeed) * p.maxSpeed;\n        }\n        \n        // Update position using delta time for smooth animation\n        p.x += p.speedX * (delta / 16); // Normalize to 60fps\n        p.y += p.speedY * (delta / 16);\n        \n        // Bounce off edges with slight randomization for more natural movement\n        if (p.x < 0 || p.x > canvas.width) {\n          p.speedX = -p.speedX * (0.9 + Math.random() * 0.2);\n          p.x = Math.max(0, Math.min(canvas.width, p.x)); // Keep within bounds\n        }\n        if (p.y < 0 || p.y > canvas.height) {\n          p.speedY = -p.speedY * (0.9 + Math.random() * 0.2);\n          p.y = Math.max(0, Math.min(canvas.height, p.y)); // Keep within bounds\n        }\n        \n        // Only connect to a subset of nearby particles for performance with many particles\n        if (i % 3 === 0) { // Only check connections for 1/3 of particles\n          for (let j = i + 1; j < Math.min(particles.length, i + 30); j++) {\n            const p2 = particles[j];\n            const distance = Math.sqrt(\n              Math.pow(p.x - p2.x, 2) + Math.pow(p.y - p2.y, 2)\n            );\n            \n            if (distance < connectDistance) {\n              ctx.beginPath();\n              // Use gradient for connections\n              const gradient = ctx.createLinearGradient(p.x, p.y, p2.x, p2.y);\n              gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${(1 - distance / connectDistance) * 0.5 * p.opacity})`);\n              gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, ${(1 - distance / connectDistance) * 0.5 * p2.opacity})`);\n              \n              ctx.strokeStyle = gradient;\n              ctx.lineWidth = 0.6;\n              ctx.moveTo(p.x, p.y);\n              ctx.lineTo(p2.x, p2.y);\n              ctx.stroke();\n            }\n          }\n        }\n      }\n      \n      ctx.shadowBlur = 0; // Reset shadow for performance\n      requestAnimationFrame(animate);\n    };\n    \n    // Initialize\n    handleResize();\n    window.addEventListener('resize', handleResize);\n    \n    // Start animation\n    const animationId = requestAnimationFrame(animate);\n    \n    // Cleanup\n    return () => {\n      window.removeEventListener('resize', handleResize);\n      cancelAnimationFrame(animationId);\n    };\n  }, [particleColor, particleCount, minSize, maxSize, speed, connectDistance]);\n  \n  return (\n    <canvas\n      ref={canvasRef}\n      className={`absolute inset-0 w-full h-full ${className || ''}`}\n      style={{ backgroundColor: 'transparent' }}\n    />\n  );\n};\n\nexport default SimpleSparkles; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}